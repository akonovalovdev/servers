package mysql

// Данный файл будет содержать код, специально предназначенный для работы с заметками
// в нашей MySQL базе данных. В этом файле мы определим новый тип SnippetModel
// и реализуем в нем некоторые методы для доступа и управления базой данных

import (
	"database/sql"
	"github.com/akonovalovdev/servers/snippetbox/pkg/models"
)

// SnippetModel - Определяем тип который обертывает пул подключения sql.DB
type SnippetModel struct {
	DB *sql.DB
}

// Insert - Метод для создания новой заметки в базе дынных.
/*
Go предоставляет три различных метода для выполнения запросов к базе данных:

DB.Query() используется для SELECT запросов, которые возвращают несколько рядов данных из таблицы,
например «все записи за сегодня«;
DB.QueryRow() используется для SELECT запросов, которые возвращают один ряд,
например «только одну запись у которой ID = 10«;
DB.Exec() используется для операторов, которые не возвращают данные (вроде INSERT и DELETE).
Добавление данных или их удаление из базы данных.
*/
func (m *SnippetModel) Insert(title, content, expires string) (int, error) {
	/* В нашем случае, подходящим инструментом будет DB.Exec() */
	// Ниже будет SQL запрос, который мы хотим выполнить. Мы разделили его на две строки
	// для удобства чтения (поэтому он окружен обратными кавычками
	// вместо обычных двойных кавычек).
	stmt := `INSERT INTO snippets (title, content, created, expires)
    VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))`
	/*
		Обратите внимание, что в этом запросе мы используем знак ? для указания плейсхолдера
		для данных, которых требуется вставить в базу данных. Так как данные,
		которые мы будем использовать, в конечном итоге будут поступать к нам от пользователя из HTML формы,
		рекомендуется использовать плейсхолдеры вместо вставки данных напрямую в SQL запросе.

		Если вы не будете использовать плейсхолдеры, то вы рискуете оставить уязвимость в виде SQL-инъекции.
	*/

	// Используем метод Exec() из встроенного пула подключений для выполнения
	// запроса. Первый параметр это сам SQL запрос, за которым следует
	// заголовок заметки, содержимое и срок жизни заметки. Этот
	// метод возвращает объект sql.Result, который содержит некоторые основные
	// данные о том, что произошло после выполнении запроса.
	/*
		Под «капотом», метод DB.Exec() работает в три этапа:

		Он создает новый подготовленный запрос в базу данных, используя предоставленный SQL оператор.
		База данных парсирует и компилирует запрос, а затем хранит его готовым к выполнению;

		На втором шаге, Exec() передает значения параметров в базу данных. Затем база данных выполняет
		подготовленный запрос, используя эти параметры. Параметры передаются позже, поэтому после компиляции запроса,
		база данных рассматривает их как чистые данные. Они не могут изменить цель оператора.
		До тех пор, пока исходный оператор получен из ненадежных данных, инъекция не может произойти;

		Затем он закрывает подготовленный запрос к базе данных.
	*/
	result, err := m.DB.Exec(stmt, title, content, expires)
	if err != nil {
		return 0, err
	}
	/*
		Мы составили SQL запрос, используя плейсхолдеры, где знак ? выступал в качестве плейсхолдера для данных,
		которые требуется вставить

		Топорный перевод для плейсхолдера будет «придержи мне место» под будущие данные.

		Любые данные которые нужно вставить в базу данных нужно сперва «подготовить» прежде
		чем выполнить запрос. Даже если пользователь вместо заголовка заметки отправит какой-то вредоносный
		SQL запрос (SQL инъекция), то используя плейсхолдеры, эти запросы не навредят базе данных

		Синтаксис параметра плейсхоледера различается в зависимости от базы данных.
		MySQL, SQL Server и SQLite используют символ ?,
		!!!но >>>>>>>>>>>>PostgreSQL использует $N<<<<<<<<<<<<<<<<<<<<<<<<<<<<.
		К примеру , если бы вы использовали PostgreSQL, вы бы создали запись таким образом:
		_, err := m.DB.Exec("INSERT INTO ... VALUES ($1, $2, $3)", ...)
	*/

	// Используем метод LastInsertId(), чтобы получить последний ID
	// созданной записи из таблицу snippets.
	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	/*
		 Интерфейс sql.Result, который мы получаем после выполнения DB.Exec(), предоставляет два метода:

		 LastInsertId() возвращает целое число (int64), сгенерированное базой данных в ответ на выполненную команду вставки.
		 Обычно это происходит в столбце id с «автоматическим инкрементом» при создании новой записи. Это наш случай;

		 RowsAffected() возвращает количество строк (в виде int64),
		 которые были как-то затронуты (изменены) после выполненных действий.

		 Важно: Не все драйверы и базы данных поддерживают методы LastInsertId() и RowsAffected().
		!Например, LastInsertId() >>>>>>>>> не поддерживается в PostgreSQL <<<<<<<<<<<<<.
		 Если вы планируете использовать данные методы, то нужно сначала проверить документацию для вашего драйвера.

		Лучше всего игнорировать возвращаемое значение из sql.Result, если оно вам не нужно. Делается это таким образом:
		_, err := m.DB.Exec("INSERT INTO ...", ...)
	*/

	// Возвращаемый ID имеет тип int64, поэтому мы конвертируем его в тип int
	// перед возвратом из метода.
	return int(id), nil
}

// Get - Метод для возвращения данных заметки по её идентификатору ID.
func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
	return nil, nil
}

// Latest - Метод возвращает 10 наиболее часто используемые заметки.
func (m *SnippetModel) Latest() ([]*models.Snippet, error) {
	return nil, nil
}
