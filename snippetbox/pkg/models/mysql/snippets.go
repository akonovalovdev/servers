package mysql

// Данный файл будет содержать код, специально предназначенный для работы с заметками
// в нашей MySQL базе данных. В этом файле мы определим новый тип SnippetModel
// и реализуем в нем некоторые методы для доступа и управления базой данных
/*
	Метод rows.Scan(), автоматически преобразует MySQL типы в типы языка программирования Go:

	CHAR, VARCHAR и TEXT соответствуют типу string;
	BOOLEAN соответствует bool;
	INT соответствует int;
	BIGINT соответствует int64;
	DECIMAL и NUMERIC соответствуют float;
	TIME, DATE и TIMESTAMP соответствуют time.Time.
*/

import (
	"database/sql"
	"errors"
	"github.com/akonovalovdev/servers/snippetbox/pkg/models"
)

/*
	Пакет database/sql в Go

	Пока вы используете пакет database/sql, ваш код будет работать с любым типом SQL базы данных — будь то MySQL,
	PostgreSQL, SQLite или что-то еще. Это означает, что ваше приложение не зависит от определённой базы данных,
	которую вы используете в настоящее время. Следовательно, вы можете менять базу данных в будущем,
	не переписывая весь код (за исключением специфических особенностей драйвера и SQL запросов).

	НО Всегда нужно ознакомиться с документацией к новому драйверу,
	чтобы понять его особенности перед началом его использования.

	- NUll
	Как правило, проще всего вообще избегать значений NULL.
	Поставьте ограничения NOT NULL для всех столбцов базы данных, как мы это сделали в этом курсе.
	Или заменить string на тип sql.NullString
	- ТРАНЗАКЦИИ
	Для гарантии использования одного и того же соединения(вызовы Exec(), Query() и QueryRow()
	могут использовать любое соединение из пула) можно заключить в транзакцию несколько SQL-операторов.
	- УПРАВЛЕНИЕ SQL СОЕДИНЕНИЯМИ В GO
	Пул подключений sql.DB состоит из соединений, которые либо простаивают, либо используются
	Эти значения можно изменить с помощью методов SetMaxOpenConns() и SetMaxIdleConns() но не более максимум
	установленного в самой базе данных(Такие моменты лучше настраивать в конфигурационном файле самой базы данных)
*/

// SnippetModel - Определяем тип который обертывает пул подключения sql.DB
type SnippetModel struct {
	DB *sql.DB
}

// Insert - Метод для создания новой заметки в базе дынных.
/*
Go предоставляет три различных метода для выполнения запросов к базе данных:

DB.Query() используется для SELECT запросов, которые возвращают несколько рядов данных из таблицы,
например «все записи за сегодня«;
DB.QueryRow() используется для SELECT запросов, которые возвращают один ряд,
например «только одну запись у которой ID = 10«;
DB.Exec() используется для операторов, которые не возвращают данные (вроде INSERT и DELETE).
Добавление данных или их удаление из базы данных.
*/
func (m *SnippetModel) Insert(title, content, expires string) (int, error) {
	/* В нашем случае, подходящим инструментом будет DB.Exec() */
	// Ниже будет SQL запрос, который мы хотим выполнить. Мы разделили его на две строки
	// для удобства чтения (поэтому он окружен обратными кавычками
	// вместо обычных двойных кавычек).
	stmt := `INSERT INTO snippets (title, content, created, expires)
    VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))`
	/*
		Обратите внимание, что в этом запросе мы используем знак ? для указания плейсхолдера
		для данных, которых требуется вставить в базу данных. Так как данные,
		которые мы будем использовать, в конечном итоге будут поступать к нам от пользователя из HTML формы,
		рекомендуется использовать плейсхолдеры вместо вставки данных напрямую в SQL запросе.

		Если вы не будете использовать плейсхолдеры, то вы рискуете оставить уязвимость в виде SQL-инъекции.
	*/

	// Используем метод Exec() из встроенного пула подключений для выполнения
	// запроса. Первый параметр это сам SQL запрос, за которым следует
	// заголовок заметки, содержимое и срок жизни заметки. Этот
	// метод возвращает объект sql.Result, который содержит некоторые основные
	// данные о том, что произошло после выполнении запроса.
	/*
		Под «капотом», метод DB.Exec() работает в три этапа:

		Он создает новый подготовленный запрос в базу данных, используя предоставленный SQL оператор.
		База данных парсирует и компилирует запрос, а затем хранит его готовым к выполнению;

		На втором шаге, Exec() передает значения параметров в базу данных. Затем база данных выполняет
		подготовленный запрос, используя эти параметры. Параметры передаются позже, поэтому после компиляции запроса,
		база данных рассматривает их как чистые данные. Они не могут изменить цель оператора.
		До тех пор, пока исходный оператор получен из ненадежных данных, инъекция не может произойти;

		Затем он закрывает подготовленный запрос к базе данных.
	*/
	result, err := m.DB.Exec(stmt, title, content, expires)
	if err != nil {
		return 0, err
	}
	/*
		Мы составили SQL запрос, используя плейсхолдеры, где знак ? выступал в качестве плейсхолдера для данных,
		которые требуется вставить

		Топорный перевод для плейсхолдера будет «придержи мне место» под будущие данные.

		Любые данные которые нужно вставить в базу данных нужно сперва «подготовить» прежде
		чем выполнить запрос. Даже если пользователь вместо заголовка заметки отправит какой-то вредоносный
		SQL запрос (SQL инъекция), то используя плейсхолдеры, эти запросы не навредят базе данных

		Синтаксис параметра плейсхоледера различается в зависимости от базы данных.
		MySQL, SQL Server и SQLite используют символ ?,
		!!!но >>>>>>>>>>>>PostgreSQL использует $N<<<<<<<<<<<<<<<<<<<<<<<<<<<<.
		К примеру , если бы вы использовали PostgreSQL, вы бы создали запись таким образом:
		_, err := m.DB.Exec("INSERT INTO ... VALUES ($1, $2, $3)", ...)
	*/

	// Используем метод LastInsertId(), чтобы получить последний ID
	// созданной записи из таблицу snippets.
	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	/*
		 Интерфейс sql.Result, который мы получаем после выполнения DB.Exec(), предоставляет два метода:

		 LastInsertId() возвращает целое число (int64), сгенерированное базой данных в ответ на выполненную команду вставки.
		 Обычно это происходит в столбце id с «автоматическим инкрементом» при создании новой записи. Это наш случай;

		 RowsAffected() возвращает количество строк (в виде int64),
		 которые были как-то затронуты (изменены) после выполненных действий.

		 Важно: Не все драйверы и базы данных поддерживают методы LastInsertId() и RowsAffected().
		!Например, LastInsertId() >>>>>>>>> не поддерживается в PostgreSQL <<<<<<<<<<<<<.
		 Если вы планируете использовать данные методы, то нужно сначала проверить документацию для вашего драйвера.

		Лучше всего игнорировать возвращаемое значение из sql.Result, если оно вам не нужно. Делается это таким образом:
		_, err := m.DB.Exec("INSERT INTO ...", ...)
	*/

	// Возвращаемый ID имеет тип int64, поэтому мы конвертируем его в тип int
	// перед возвратом из метода.
	return int(id), nil
}

// Get - Метод для возвращения данных заметки по её идентификатору ID.
func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
	// SQL запрос для получения данных одной записи.
	stmt := `SELECT id, title, content, created, expires FROM snippets
    WHERE expires > UTC_TIMESTAMP() AND id = ?`

	// Используем метод QueryRow() для выполнения SQL запроса,
	// передавая ненадежную переменную id в качестве значения для плейсхолдера
	// Возвращается указатель на объект sql.Row, который содержит данные записи.
	row := m.DB.QueryRow(stmt, id)

	// Инициализируем указатель на новую структуру Snippet.
	s := &models.Snippet{}

	// Используйте row.Scan(), чтобы скопировать значения из каждого поля от sql.Row в
	// соответствующее поле в структуре Snippet. Обратите внимание, что аргументы
	// для row.Scan - это указатели на место, куда требуется скопировать данные
	// и количество аргументов должно быть точно таким же, как количество
	// столбцов в таблице базы данных.
	err := row.Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
	if err != nil {
		// Специально для этого случая, мы проверим при помощи функции errors.Is()
		// если запрос был выполнен с ошибкой. Если ошибка обнаружена, то
		// возвращаем нашу ошибку из модели models.ErrNoRecord.
		if errors.Is(err, sql.ErrNoRows) {
			return nil, models.ErrNoRecord
			/*
				Возвращаем ошибку models.ErrNoRecord вместо sql.ErrNoRows,т.к. требуется полностью инкапсулировать
				модель, чтобы приложение не было связано с базовым хранилищем данных или зависело от ошибок бд.
			*/
		} else {
			return nil, err
		}
	}

	// Если все хорошо, возвращается объект Snippet.
	return s, nil
}

// Latest - Метод возвращает 10 наиболее часто используемые заметки.
func (m *SnippetModel) Latest() ([]*models.Snippet, error) {
	// Пишем SQL запрос, который мы хотим выполнить.
	stmt := `SELECT id, title, content, created, expires FROM snippets
    WHERE expires > UTC_TIMESTAMP() ORDER BY created DESC LIMIT 10`

	// Используем метод Query() для выполнения нашего SQL запроса.
	// В ответ мы получим sql.Rows, который содержит результат нашего запроса.
	rows, err := m.DB.Query(stmt)
	if err != nil {
		return nil, err
	}
	/*
		Закрытие набора результатов с использованием defer rows.Close() является очень важным моментом.
		Пока набор результатов открыт, он будет поддерживать соединение с базовой базой данных открытым… поэтому,
		если в этом методе что-то пойдет не так и набор результатов не будет закрыт,
		это приведет к тому, что соединения с базой данных будет израсходовано в пустую.
	*/

	// Откладываем вызов rows.Close(), чтобы быть уверенным, что набор результатов из sql.Rows
	// правильно закроется перед вызовом метода Latest(). Этот оператор откладывания
	// должен выполнится *после* проверки на наличие ошибки в методе Query().
	// В противном случае, если Query() вернет ошибку, это приведет к панике
	// так как он попытается закрыть набор результатов у которого значение: nil.
	defer rows.Close()

	// Инициализируем пустой срез для хранения объектов models.Snippets.
	var snippets []*models.Snippet

	// Используем rows.Next() для перебора результата. Этот метод предоставляем
	// первый а затем каждую следующею запись из базы данных для обработки
	// методом rows.Scan().
	for rows.Next() {
		// Создаем указатель на новую структуру Snippet
		s := &models.Snippet{}
		// Используем rows.Scan(), чтобы скопировать значения полей в структуру.
		// Опять же, аргументы предоставленные в row.Scan()
		// должны быть указателями на место, куда требуется скопировать данные и
		// количество аргументов должно быть точно таким же, как количество
		// столбцов из таблицы базы данных, возвращаемых вашим SQL запросом.
		err = rows.Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
		if err != nil {
			return nil, err
		}
		// Добавляем структуру в срез.
		snippets = append(snippets, s)
	}

	// Когда цикл rows.Next() завершается, вызываем метод rows.Err(), чтобы узнать
	// если в ходе работы у нас не возникла какая либо ошибка.
	if err = rows.Err(); err != nil {
		return nil, err
	}

	// Если все в порядке, возвращаем срез с данными.
	return snippets, nil
}
