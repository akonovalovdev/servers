package main

import (
	"log"
	"net/http"
)

// Обработчик главной страницы.
func home(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Привет из Snippetbox"))
}

// Обработчик для отображения содержимого заметки.
func showSnippet(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Отображение заметки..."))
}

// Обработчик для создания новой заметки.
func createSnippet(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Форма для создания новой заметки..."))
}

/*
В Go поддерживает два разных типа URL-шаблонов: фиксированные пути и многоуровневые пути.
Фиксированные пути не заканчиваются косой чертой, тогда как многоуровневые пути заканчиваются косой чертой.

Два наших новых шаблона — "/snippet" и "/snippet/create" — являются примерами фиксированных путей.
В servemux такие шаблоны фиксированного пути сопоставляются (и вызывается соответствующий обработчик)
только тогда, когда путь URL-запроса точно совпадает с фиксированным путем.

В то время как, роутинг "/" является примером многоуровневого пути (потому что он заканчивается косой чертой).
Другим примером является что-то вроде "/static/". Шаблоны путей сопоставляются (вызывается соответствующий обработчик)
всякий раз, когда начало пути URL запроса совпадает с путем поддерева.

У многоуровневых путей в конце может быть какой-то вспомогательный символ. К примеру, "/**" или "/static/**".

Теперь понятно, почему шаблон "/" действует по сценарию «catch-all» (ловим все запросы). По сути, данный шаблон
означает совпадение с одним слэшем, за которым следует что-нибудь (или вообще ничего).
*/

func main() {
	// Регистрируем два новых обработчика и соответствующие URL-шаблоны в
	// маршрутизаторе servemux
	mux := http.NewServeMux()
	mux.HandleFunc("/", home)
	mux.HandleFunc("/snippet", showSnippet)
	mux.HandleFunc("/snippet/create", createSnippet)

	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
	err := http.ListenAndServe(":4000", mux)
	log.Fatal(err)
}

// Первая версия мэйн
//package main
//
//import (
//	"log"
//	"net/http"
//)
//
//// 1 нам потребуется обработчик(контроллер)
//// Он отвечает за выполнение логики приложения, а также за заголовок и тело HTTP ответа
//
//// 2 - маршрутизатор HTTP запросов (или servemux в Go терминологии).
//// Он хранит связь между URL-шаблонами приложения и соответствующими обработчиками.
//// В приложении один servemux, который содержит все URL маршруты
//
//// Последний - веб-сервер. Одним из преимуществ Go является то, что вы можете использовать встроенный веб-сервер
//// и прослеживать входящие HTTP запросы и все это будет частью самого приложения
////________________________________________________________________________________________________________
//
//// Создается функция-обработчик "home", которая записывает байтовый слайс, содержащий
//// текст "Привет из Snippetbox" как тело ответа.
//func home(w http.ResponseWriter, r *http.Request) {
//	w.Write([]byte("Привет из Snippetbox"))
//}
//
///*
//Функция-обработчик home является обычной функцией с двумя параметрами.
//Параметр http.ResponseWriter предоставляет методы для объединения HTTP ответа и возвращение его пользователю,
//а второй параметр *http.Request является указателем на структуру, которая содержит информацию
//о текущем запросе (вроде HTTP-методов POST, GET, DELETE… и URL текущего запроса)
//*/
//
//func main() {
//	// Используется функция http.NewServeMux() для инициализации нового роутера, затем
//	// функцию "home" регистрируется как обработчик для URL-шаблона "/".
//	mux := http.NewServeMux()
//	mux.HandleFunc("/", home)
//	/*
//		маршрутизатор рассматривает URL-шаблон "/" как «catch-all» — то есть всеобщий захват.
//		Так, что на данный момент все HTTP запросы к веб-серверу будут обрабатываться функцией home,
//		вне зависимости от их URL пути. К примеру, при переходе на другой URL
//		вроде http://localhost:4000/foo будет получен тот же ответ
//	*/
//
//	// Используется функция http.ListenAndServe() для запуска нового веб-сервера.
//	// Мы передаем два параметра: TCP-адрес сети для прослушивания (в данном случае это "localhost:4000")
//	// и созданный роутер. Если вызов http.ListenAndServe() возвращает ошибку
//	// мы используем функцию log.Fatal() для логирования ошибок. Обратите внимание
//	// что любая ошибка, возвращаемая от http.ListenAndServe(), всегда non-nil.
//	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
//	err := http.ListenAndServe(":4000", mux)
//	log.Fatal(err)
//}
