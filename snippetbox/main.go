package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
)

// Обработчик главной страницы.
func home(w http.ResponseWriter, r *http.Request) {
	// Проверяется, если текущий путь URL запроса точно совпадает с шаблоном "/". Если нет, вызывается
	// функция http.NotFound() для возвращения клиенту ошибки 404.
	// Важно, чтобы мы завершили работу обработчика через return. Если мы забудем про "return", то обработчик
	// продолжит работу и выведет сообщение "Привет из SnippetBox" как ни в чем не бывало.
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	w.Write([]byte("Привет из Snippetbox\n"))
}

// Обработчик для отображения содержимого заметки.
func showSnippet(w http.ResponseWriter, r *http.Request) {
	// Извлекаем значение параметра id из URL и попытаемся
	// конвертировать строку в integer используя функцию strconv.Atoi(). Если его нельзя
	// конвертировать в integer, или значение меньше 1, возвращаем ответ
	// 404 - страница не найдена!
	id, err := strconv.Atoi(r.URL.Query().Get("id"))
	if err != nil || id < 1 {
		http.NotFound(w, r)
		return
	}

	// Используем функцию fmt.Fprintf() для вставки значения из id в строку ответа
	// и записываем его в http.ResponseWriter.
	fmt.Fprintf(w, "Отображение выбранной заметки с ID %d...", id)
}

// Обработчик для создания новой заметки.
func createSnippet(w http.ResponseWriter, r *http.Request) {
	// Используем r.Method для проверки, использует ли запрос метод POST или нет. Обратите внимание,
	// что http.MethodPost является строкой и содержит текст "POST".
	if r.Method != http.MethodPost {
		// Используем метод Header().Set() для добавления заголовка 'Allow: POST' в
		// карту HTTP-заголовков. Первый параметр - название заголовка, а
		// второй параметр - значение заголовка.
		w.Header().Set("Allow", http.MethodPost)
		/*
			Внимание: Вы должны сперва вызвать метод w.Header().Set()
			и уже потом остальные методы w.WriteHeader() или w.Write()
			иначе ваши изменения не будут учтены.
		*/
		// Если это не так, то вызывается метод w.WriteHeader() для возвращения статус-кода 405
		// и вызывается метод w.Write() для возвращения тела-ответа с текстом "Метод запрещен".
		// Затем мы завершаем работу функции вызовав "return"
		w.WriteHeader(405) // 405 - введённый метод запрещён
		w.Write([]byte("GET-Метод запрещен!"))
		return
		/*
			Вызвать метод w.WriteHeader() в обработчике можно только один раз,
			и после возвращения кода состояния HTTP, изменить его нельзя.
			Если попытаться вызвать w.WriteHeader() во второй раз, Go выдаст сообщение об ошибке;

			Если не вызывать метод w.WriteHeader() напрямую, тогда первый вызов w.Write()
			автоматически отправит пользователю код состояния 200 OK.
			Поэтому, если вы хотите вернуть другой код состояния,
			вызовите один раз метод w.WriteHeader() перед любым вызовом w.Write().
		*/
	}

	w.Write([]byte("Создание новой заметки..."))
}

/*
В Go поддерживает два разных типа URL-шаблонов: фиксированные пути и многоуровневые пути.
Фиксированные пути не заканчиваются косой чертой, тогда как многоуровневые пути заканчиваются косой чертой.

Два наших новых шаблона — "/snippet" и "/snippet/create" — являются примерами фиксированных путей.
В servemux такие шаблоны фиксированного пути сопоставляются (и вызывается соответствующий обработчик)
только тогда, когда путь URL-запроса точно совпадает с фиксированным путем.

В то время как, роутинг "/" является примером многоуровневого пути (потому что он заканчивается косой чертой).
Другим примером является что-то вроде "/static/". Шаблоны путей сопоставляются (вызывается соответствующий обработчик)
всякий раз, когда начало пути URL запроса совпадает с путем поддерева.

У многоуровневых путей в конце может быть какой-то вспомогательный символ. К примеру, "/**" или "/static/**".

Теперь понятно, почему шаблон "/" действует по сценарию «catch-all» (ловим все запросы). По сути, данный шаблон
означает совпадение с одним слэшем, за которым следует что-нибудь (или вообще ничего).
*/

func main() {
	// Регистрируем два новых обработчика и соответствующие URL-шаблоны в
	// маршрутизаторе servemux
	mux := http.NewServeMux()
	mux.HandleFunc("/", home)
	mux.HandleFunc("/snippet", showSnippet)
	mux.HandleFunc("/snippet/create", createSnippet)

	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
	err := http.ListenAndServe(":4000", mux)
	log.Fatal(err)
}

// Первая версия мэйн
//package main
//
//import (
//	"log"
//	"net/http"
//)
//
//// 1 нам потребуется обработчик(контроллер)
//// Он отвечает за выполнение логики приложения, а также за заголовок и тело HTTP ответа
//
//// 2 - маршрутизатор HTTP запросов (или servemux в Go терминологии).
//// Он хранит связь между URL-шаблонами приложения и соответствующими обработчиками.
//// В приложении один servemux, который содержит все URL маршруты
//
//// Последний - веб-сервер. Одним из преимуществ Go является то, что вы можете использовать встроенный веб-сервер
//// и прослеживать входящие HTTP запросы и все это будет частью самого приложения
////________________________________________________________________________________________________________
//
//// Создается функция-обработчик "home", которая записывает байтовый слайс, содержащий
//// текст "Привет из Snippetbox" как тело ответа.
//func home(w http.ResponseWriter, r *http.Request) {
//	w.Write([]byte("Привет из Snippetbox"))
//}
//
///*
//Функция-обработчик home является обычной функцией с двумя параметрами.
//Параметр http.ResponseWriter предоставляет методы для объединения HTTP ответа и возвращение его пользователю,
//а второй параметр *http.Request является указателем на структуру, которая содержит информацию
//о текущем запросе (вроде HTTP-методов POST, GET, DELETE… и URL текущего запроса)
//*/
//
//func main() {
//	// Используется функция http.NewServeMux() для инициализации нового роутера, затем
//	// функцию "home" регистрируется как обработчик для URL-шаблона "/".
//	mux := http.NewServeMux()
//	mux.HandleFunc("/", home)
//	/*
//		маршрутизатор рассматривает URL-шаблон "/" как «catch-all» — то есть всеобщий захват.
//		Так, что на данный момент все HTTP запросы к веб-серверу будут обрабатываться функцией home,
//		вне зависимости от их URL пути. К примеру, при переходе на другой URL
//		вроде http://localhost:4000/foo будет получен тот же ответ
//	*/
//
//	// Используется функция http.ListenAndServe() для запуска нового веб-сервера.
//	// Мы передаем два параметра: TCP-адрес сети для прослушивания (в данном случае это "localhost:4000")
//	// и созданный роутер. Если вызов http.ListenAndServe() возвращает ошибку
//	// мы используем функцию log.Fatal() для логирования ошибок. Обратите внимание
//	// что любая ошибка, возвращаемая от http.ListenAndServe(), всегда non-nil.
//	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
//	err := http.ListenAndServe(":4000", mux)
//	log.Fatal(err)
//}

// тест методов GET  и POST
//func home(w http.ResponseWriter, r *http.Request) {
//if r.Method == http.MethodGet {
//		w.Write([]byte("Привет из Snippetbox\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//
//	if r.Method == http.MethodPost {
//		w.Write([]byte("Сохраняем в базу данных\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//	w.WriteHeader(http.StatusBadRequest)
//	w.Write([]byte("НЕкорректный метод:" + r.Method + "\n"))
//}
