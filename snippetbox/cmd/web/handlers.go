package main

// импортируемый 	"html/template"
import (
	"errors"
	"fmt"
	"github.com/akonovalovdev/servers/snippetbox/pkg/models"
	"html/template"
	"net/http"
	"strconv"
)

// 4я версия handlers отправка 10 запросов
func (app *application) home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		app.notFound(w)
		return
	}

	s, err := app.snippets.Latest()
	if err != nil {
		app.serverError(w, err)
		return
	}

	// Создаем экземпляр структуры templateData,
	// содержащий срез с заметками.
	data := &templateData{Snippets: s}

	files := []string{
		"./snippetbox/ui/html/home.page.tmpl",
		"./snippetbox/ui/html/base.layout.tmpl",
		"./snippetbox/ui/html/footer.partial.tmpl",
	}

	ts, err := template.ParseFiles(files...)
	if err != nil {
		app.serverError(w, err)
		return
	}

	// Передаем структуру templateData в шаблонизатор.
	// Теперь она будет доступна внутри файлов шаблона через точку.
	err = ts.Execute(w, data)
	if err != nil {
		app.serverError(w, err)
	}
}
func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.Atoi(r.URL.Query().Get("id"))
	if err != nil || id < 1 {
		app.notFound(w)
		return
	}

	s, err := app.snippets.Get(id)
	if err != nil {
		if errors.Is(err, models.ErrNoRecord) {
			app.notFound(w)
		} else {
			app.serverError(w, err)
		}
		return
	}

	// Создаем экземпляр структуры templateData, содержащей данные заметки.
	// Обратите внимание на передачу заметки с данными (структура models.Snippet) в качестве последнего параметра.
	data := &templateData{Snippet: s}

	// Инициализируем срез, содержащий путь к файлу show.page.tmpl
	// Добавив еще базовый шаблон и часть футера, который мы сделали ранее.
	files := []string{
		"./snippetbox/ui/html/show.page.tmpl",
		"./snippetbox/ui/html/base.layout.tmpl",
		"./snippetbox/ui/html/footer.partial.tmpl",
	}
	// Парсинг файлов шаблонов...
	ts, err := template.ParseFiles(files...)
	if err != nil {
		app.serverError(w, err)
		return
	}
	// А затем выполняем их.
	// Передаем структуру templateData в качестве данных для шаблона.
	err = ts.Execute(w, data)
	if err != nil {
		app.serverError(w, err)
	}
}

func (app *application) createSnippet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		app.clientError(w, http.StatusMethodNotAllowed)
		return
	}

	title := "История про улитку"
	content := "Улитка выползла из раковины,\nвытянула рожки,\nи опять подобрала их."
	expires := "7"

	id, err := app.snippets.Insert(title, content, expires)
	if err != nil {
		app.serverError(w, err)
		return
	}
	http.Redirect(w, r, fmt.Sprintf("/snippet?id=%d", id), http.StatusSeeOther)
}

//// 3 версия handlers (Логирование)
///*
//логгеры infoLog и errorLog не видны из за области видимости функции main()
//
//У большинства веб-приложений будет несколько зависимостей, к которым их обработчики должны обращаться.
//Например пул соединений с базой данных, централизованные обработчики ошибок и кэши шаблонов.
//
//Как сделать любую зависимость доступной нашим обработчикам?
//- Глобальная переменная выручит, но усложнит тестирование и повысит риск возникновение ошибок
//
//- Для приложений, в которых все обработчики находятся в одном пакете (как наше приложение),
//отличным способом внедрения зависимостей будет их размещение в структуру application
//
//В файле main.go создаём новую структуру application
//*/
//
//// Меняем сигнатуры обработчика home, чтобы он определялся как метод
//// структуры *application.
//func (app *application) home(w http.ResponseWriter, r *http.Request) {
//	if r.URL.Path != "/" {
//		app.notFound(w) // Использование помощника notFound() из halpers.go
//		return
//	}
//	files := []string{
//		"./snippetbox/ui/html/home.page.tmpl",
//		"./snippetbox/ui/html/base.layout.tmpl",
//		"./snippetbox/ui/html/footer.partial.tmpl",
//	}
//	ts, err := template.ParseFiles(files...)
//	if err != nil {
//		// Поскольку обработчик home теперь является методом структуры application
//		// он может получить доступ к логгерам из структуры.
//		// Используем их вместо стандартного логгера от Go.
//		// app.errorLog.Println(err.Error()) // заменили на общий логгер из helpers чтобы не повторяться
//
//		app.serverError(w, err) // Использование помощника serverError() из halpers
//		return
//	}
//	err = ts.Execute(w, nil)
//	if err != nil {
//		// Обновляем код для использования логгера-ошибок
//		// из структуры application.
//		// app.errorLog.Println(err.Error()) // заменили на общий логгер из helpers чтобы не повторяться
//		app.serverError(w, err) // Использование помощника serverError() из halpers
//	}
//}
//
//// Меняем сигнатуру обработчика showSnippet, чтобы он был определен как метод
//// структуры *application
//func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
//	id, err := strconv.Atoi(r.URL.Query().Get("id"))
//	if err != nil || id < 1 {
//		// Использование помощника notFound() из halpers.go
//		app.notFound(w) // Страница не найдена.
//		return
//	}
//
//	// Вызываем метода Get из модели Snipping для извлечения данных для
//	// конкретной записи на основе её ID. Если подходящей записи не найдено,
//	// то возвращается ответ 404 Not Found (Страница не найдена).
//	s, err := app.snippets.Get(id)
//	if err != nil {
//		if errors.Is(err, models.ErrNoRecord) {
//			app.notFound(w)
//		} else {
//			app.serverError(w, err)
//		}
//		return
//	}
//
//	// Отображаем весь вывод на странице.
//	fmt.Fprintf(w, "%v", s)
//}
//// Меняем сигнатуру обработчика createSnippet, чтобы он определялся как метод
//// структуры *application.
//func (app *application) createSnippet(w http.ResponseWriter, r *http.Request) {
//	if r.Method != http.MethodPost {
//		w.Header().Set("Allow", http.MethodPost)
//		app.clientError(w, http.StatusMethodNotAllowed)
//		return
//	}
//
//	// Создаем несколько переменных, содержащих тестовые данные. Мы удалим их позже.
//	title := "История про улитку"
//	content := "Улитка выползла из раковины,\nвытянула рожки,\nи опять подобрала их."
//	expires := "7"
//
//	// Передаем данные в метод SnippetModel.Insert(), получая обратно ID только что созданной записи в базу данных.
//	id, err := app.snippets.Insert(title, content, expires)
//	if err != nil {
//		app.serverError(w, err)
//		return
//	}
//
//	// Перенаправляем пользователя на соответствующую страницу заметки.
//	http.Redirect(w, r, fmt.Sprintf("/snippet?id=%d", id), http.StatusSeeOther)
//}

//---------------------------------------------------------------------------------------------------------------
// Вторая версия handlers (Работа с HTML шаблонами + разьяснение по обработчику)
///*
//	Под обработчиком подразумевается объект, который удовлетворяет интерфейсу http.Handler
//
//	То есть для того чтобы объект считался обработчиком, у него должен быть метод ServeHTTP() со следующей сигнатурой
//	ServeHTTP(http.ResponseWriter, *http.Request)
//
//	Самая простая форма обработчика будет выглядеть наподобие следующего примера:
//	type home struct {}
//	func (h *home) ServeHTTP(w http.ResponseWriter, r *http.Request) {
//    	w.Write([]byte("Это моя домашняя страница"))
//	}
//	Здесь у нас есть объект (в данном случае это структура home, но это также может быть строка, функция или
//	что-то другое), и мы реализовали для неё метод с сигнатурой ServeHTTP(http.ResponseWriter, *http.Request).
//	Это все, что требуется для создания обработчика HTTP запросов
//
//	Затем можно зарегистрировать обработчик с помощью servemux (маршрутизатор HTTP запросов),
//	используя метод Handle следующим образом:
//	mux := http.NewServeMux()
//	mux.Handle("/", &home{})
//*/
//
///*
//	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//	Важно отметить еще один момент: все входящие HTTP-запросы выполняются в собственной горутине.
//	Для загруженных серверов это означает, что код, загружаемый обработчиками
//	или вызываемый ими, скорее всего будет выполняться параллельно. Это ускоряет работу приложения,
//	но вам нужно знать и защититься от состоянии гонки при доступе к общим ресурсам из обработчиков.
//*/
//
//// Обработчик главной страницы.
//// Функция home() является самой обычной функцией.
//// У нее нет метода ServeHTTP(). Так, что по сути она не является обработчиком для HTTP запросов.
//// Она лишь имитирует работу настоящего обработчика HTTP запросов
//func home(w http.ResponseWriter, r *http.Request) {
//	// Проверяется, если текущий путь URL запроса точно совпадает с шаблоном "/". Если нет, вызывается
//	// функция http.NotFound() для возвращения клиенту ошибки 404.
//	// Важно, чтобы мы завершили работу обработчика через return. Если мы забудем про "return", то обработчик
//	// продолжит работу и выведет сообщение "Привет из SnippetBox" как ни в чем не бывало.
//
//	if r.URL.Path != "/" {
//		http.NotFound(w, r)
//		return
//	}
//
//	// Инициализируем срез содержащий пути к двум файлам. Обратите внимание, что
//	// файл home.page.tmpl должен быть *первым* файлом в срезе.
//	files := []string{
//		"./snippetbox/ui/html/home.page.tmpl",
//		"./snippetbox/ui/html/base.layout.tmpl",
//		"./snippetbox/ui/html/footer.partial.tmpl",
//	}
//
//	// Используем функцию template.ParseFiles() для чтения файла шаблона.
//	// Если возникла ошибка, мы запишем детальное сообщение ошибки и
//	// используя функцию http.Error() мы отправим пользователю
//	// ответ: 500 Internal Server Error (Внутренняя ошибка на сервере)
//
//	ts, err := template.ParseFiles(files...)
//	if err != nil {
//		log.Println(err.Error())
//		http.Error(w, "Internal Server Error", 500)
//		return
//	}
//
//	// Затем мы используем метод Execute() для записи содержимого
//	// шаблона в тело HTTP ответа. Последний параметр в Execute() предоставляет
//	// возможность отправки динамических данных в шаблон.
//	err = ts.Execute(w, nil)
//	if err != nil {
//		log.Println(err.Error())
//		http.Error(w, "Internal Server Error", 500)
//	}
//}
//
//// Обработчик для отображения содержимого заметки.
//func showSnippet(w http.ResponseWriter, r *http.Request) {
//	// Извлекаем значение параметра id из URL и попытаемся
//	// конвертировать строку в integer используя функцию strconv.Atoi(). Если его нельзя
//	// конвертировать в integer, или значение меньше 1, возвращаем ответ 404
//	/*
//		Функция должна получить значение параметра id из URL строки запроса используя метод r.URL.Query().Get().
//		Метод будет возвращать значение параметра в виде строки или пустую строку "", если нет совпадающего параметра;
//
//		Поскольку значение из параметра id является ненадежным вводом данных от пользователя,
//		значение нужно сперва проверить. Значение из параметра id должно содержать положительное целое число.
//		Это можно реализовать если мы попытаемся преобразовать строку из id в целое число
//		с помощью функции strconv.Atoi(), а затем проверим если значение больше нуля
//	*/
//	id, err := strconv.Atoi(r.URL.Query().Get("id"))
//	if err != nil || id < 1 {
//		http.NotFound(w, r)
//		return
//	}
//
//	// Используем функцию fmt.Fprintf() для вставки значения из id в строку ответа
//	// и записываем его в http.ResponseWriter.
//	fmt.Fprintf(w, "Отображение выбранной заметки с ID %d...", id)
//	/*
//		Если заглянуть в документацию для функции fmt.Fprintf(), вы увидите, что в качестве первого параметра
//		принимает интерфейс io.Writer но мы вместо него передали объект http.ResponseWriter — и все сработало хорошо.
//
//		Мы можем это сделать, потому что тип io.Writer является интерфейсом, а объект http.ResponseWriter
//		удовлетворяет интерфейсу, потому что у него есть метод w.Write().
//	*/
//}
//
//// Обработчик для создания новой заметки.
//func createSnippet(w http.ResponseWriter, r *http.Request) {
//	// Используем r.Method для проверки, использует ли запрос метод POST или нет. Обратите внимание,
//	// что http.MethodPost является строкой и содержит текст "POST".
//	if r.Method != http.MethodPost {
//		// Используем метод Header().Set() для добавления заголовка 'Allow: POST' в
//		// карту HTTP-заголовков. Первый параметр - название заголовка, а
//		// второй параметр - значение заголовка.
//		w.Header().Set("Allow", http.MethodPost)
//		/*
//			Внимание: Вы должны сперва вызвать метод w.Header().Set()
//			и уже потом остальные методы w.WriteHeader() или w.Write()
//			иначе ваши изменения не будут учтены.
//		*/
//		// Если это не так, то вызывается метод w.WriteHeader() для возвращения статус-кода 405
//		// и вызывается метод w.Write() для возвращения тела-ответа с текстом "Метод запрещен".
//		// Затем мы завершаем работу функции вызовав "return"
//		/*
//			Вызвать метод w.WriteHeader() в обработчике можно только один раз,
//			и после возвращения кода состояния HTTP, изменить его нельзя.
//			Если попытаться вызвать w.WriteHeader() во второй раз, Go выдаст сообщение об ошибке
//
//			Если не вызывать метод w.WriteHeader() напрямую, тогда первый вызов w.Write()
//			автоматически отправит пользователю код состояния 200 OK. Поэтому, если вы хотите вернуть другой код состояния,
//			вызовите один раз метод w.WriteHeader() перед любым вызовом w.Write()
//		*/
//		//w.WriteHeader(405) // 405 - введённый метод запрещён
//		//w.Write([]byte("GET-Метод запрещен!"))
//		/*
//			Если требуется отправить какой-то код состояния, кроме 200 с текстом ответа, можно использовать http.Error().
//			Это вспомогательная функция, которая принимает текст сообщения и код состояния,
//			а затем «за кулисами» сама вызывает методы w.WriteHeader() и w.Write().
//		*/
//		// Используем функцию http.Error() для отправки кода состояния 405 с соответствующим сообщением.
//		http.Error(w, "Метод запрещен!", 405)
//		return
//		/*
//			Вызвать метод w.WriteHeader() в обработчике можно только один раз,
//			и после возвращения кода состояния HTTP, изменить его нельзя.
//			Если попытаться вызвать w.WriteHeader() во второй раз, Go выдаст сообщение об ошибке;
//
//			Если не вызывать метод w.WriteHeader() напрямую, тогда первый вызов w.Write()
//			автоматически отправит пользователю код состояния 200 OK.
//			Поэтому, если вы хотите вернуть другой код состояния,
//			вызовите один раз метод w.WriteHeader() перед любым вызовом w.Write().
//		*/
//	}
//
//	w.Write([]byte("Создание новой заметки..."))
//}
//
///*
//В Go поддерживает два разных типа URL-шаблонов: фиксированные пути и многоуровневые пути.
//Фиксированные пути не заканчиваются косой чертой, тогда как многоуровневые пути заканчиваются косой чертой.
//
//Два наших новых шаблона — "/snippet" и "/snippet/create" — являются примерами фиксированных путей.
//В servemux такие шаблоны фиксированного пути сопоставляются (и вызывается соответствующий обработчик)
//только тогда, когда путь URL-запроса точно совпадает с фиксированным путем.
//
//В то время как, роутинг "/" является примером многоуровневого пути (потому что он заканчивается косой чертой).
//Другим примером является что-то вроде "/static/". Шаблоны путей сопоставляются (вызывается соответствующий обработчик)
//всякий раз, когда начало пути URL запроса совпадает с путем поддерева.
//
//У многоуровневых путей в конце может быть какой-то вспомогательный символ. К примеру, "/**" или "/static/**".
//
//Теперь понятно, почему шаблон "/" действует по сценарию «catch-all» (ловим все запросы). По сути, данный шаблон
//означает совпадение с одним слэшем, за которым следует что-нибудь (или вообще ничего).
//*/
//
///*
//УПРАВЛЕНИЕ HTTP ЗАГОЛОВКАМИ В GO
//
//// Устанавливаем новый заголовок управления кешем. Если заголовок "Cache-Control" уже указан
//// то он будет переписан.
//w.Header().Set("Cache-Control", "public, max-age=31536000")
//
//// Метод Add() добавляет новый заголовок "Cache-Control" и может
//// вызываться несколько раз.
//w.Header().Add("Cache-Control", "public")
//w.Header().Add("Cache-Control", "max-age=31536000")
//
//// Удаляем все значения из заголовка "Cache-Control".
//w.Header().Del("Cache-Control")
//
//// Получаем первое значение из заголовка "Cache-Control".
//w.Header().Get("Cache-Control")
//
//Название заголовка не чувствительно к регистру. Методы Add(), Get(), Set() и Del() в карте заголовков,
//название заголовка всегда будет обработано с помощью функции textproto.CanonicalMIMEHeaderKey().
//Эта функция преобразует первую букву и любую букву после дефиса в верхний регистр, а остальные буквы в нижний.
//
//Если требуется избежать такого поведения, можно напрямую отредактировать
//базовую карту заголовков (у нее тип map[string][]string)
//
//Метод Del() не удаляет заголовки, сгенерированные системой по умолчанию.
//Чтобы подавить их, требуется напрямую получить доступ к базовой карте заголовков и указать значение nil
//для нужного вам заголовка. К примеру, если нужно подавить заголовок Date:
//w.Header()["Date"] = nil
//*/
// ---------------------------------------------------------------------------------------------------------------
// Первая версия handlers (базовый вид - лепим на коленке чтобы работало)
//package main
//
//import (
//	"log"
//	"net/http"
//)
//
//// 1 нам потребуется обработчик(контроллер)
//// Он отвечает за выполнение логики приложения, а также за заголовок и тело HTTP ответа
//
//// 2 - маршрутизатор HTTP запросов (или servemux в Go терминологии).
//// Он хранит связь между URL-шаблонами приложения и соответствующими обработчиками.
//// В приложении один servemux, который содержит все URL маршруты
//
//// Последний - веб-сервер. Одним из преимуществ Go является то, что вы можете использовать встроенный веб-сервер
//// и прослеживать входящие HTTP запросы и все это будет частью самого приложения
////________________________________________________________________________________________________________
//
//// Создается функция-обработчик "home", которая записывает байтовый слайс, содержащий
//// текст "Привет из Snippetbox" как тело ответа.
//func home(w http.ResponseWriter, r *http.Request) {
//	w.Write([]byte("Привет из Snippetbox"))
//}
//
///*
//Функция-обработчик home является обычной функцией с двумя параметрами.
//Параметр http.ResponseWriter предоставляет методы для объединения HTTP ответа и возвращение его пользователю,
//а второй параметр *http.Request является указателем на структуру, которая содержит информацию
//о текущем запросе (вроде HTTP-методов POST, GET, DELETE… и URL текущего запроса)
//*/
//
//func main() {
//	// Используется функция http.NewServeMux() для инициализации нового роутера, затем
//	// функцию "home" регистрируется как обработчик для URL-шаблона "/".
//	mux := http.NewServeMux()
//	mux.HandleFunc("/", home)
//	/*
//		маршрутизатор рассматривает URL-шаблон "/" как «catch-all» — то есть всеобщий захват.
//		Так, что на данный момент все HTTP запросы к веб-серверу будут обрабатываться функцией home,
//		вне зависимости от их URL пути. К примеру, при переходе на другой URL
//		вроде http://localhost:4000/foo будет получен тот же ответ
//	*/
//
//	// Используется функция http.ListenAndServe() для запуска нового веб-сервера.
//	// Мы передаем два параметра: TCP-адрес сети для прослушивания (в данном случае это "localhost:4000")
//	// и созданный роутер. Если вызов http.ListenAndServe() возвращает ошибку
//	// мы используем функцию log.Fatal() для логирования ошибок. Обратите внимание
//	// что любая ошибка, возвращаемая от http.ListenAndServe(), всегда non-nil.
//	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
//	err := http.ListenAndServe(":4000", mux)
//	log.Fatal(err)
//}

// тест методов GET  и POST
//func home(w http.ResponseWriter, r *http.Request) {
//if r.Method == http.MethodGet {
//		w.Write([]byte("Привет из Snippetbox\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//
//	if r.Method == http.MethodPost {
//		w.Write([]byte("Сохраняем в базу данных\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//	w.WriteHeader(http.StatusBadRequest)
//	w.Write([]byte("НЕкорректный метод:" + r.Method + "\n"))
//}
