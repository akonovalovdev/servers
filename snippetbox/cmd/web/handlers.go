package main

import (
	"fmt"
	"html/template"
	"log"
	"net/http"
	"strconv"
)

// Обработчик главной страницы.
func home(w http.ResponseWriter, r *http.Request) {
	// Проверяется, если текущий путь URL запроса точно совпадает с шаблоном "/". Если нет, вызывается
	// функция http.NotFound() для возвращения клиенту ошибки 404.
	// Важно, чтобы мы завершили работу обработчика через return. Если мы забудем про "return", то обработчик
	// продолжит работу и выведет сообщение "Привет из SnippetBox" как ни в чем не бывало.
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	// Инициализируем срез содержащий пути к двум файлам. Обратите внимание, что
	// файл home.page.tmpl должен быть *первым* файлом в срезе.
	files := []string{
		"./snippetbox/ui/html/home.page.tmpl",
		"./snippetbox/ui/html/base.layout.tmpl",
		"./snippetbox/ui/html/footer.partial.tmpl",
	}

	// Используем функцию template.ParseFiles() для чтения файла шаблона.
	// Если возникла ошибка, мы запишем детальное сообщение ошибки и
	// используя функцию http.Error() мы отправим пользователю
	// ответ: 500 Internal Server Error (Внутренняя ошибка на сервере)

	ts, err := template.ParseFiles(files...)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
		return
	}

	// Затем мы используем метод Execute() для записи содержимого
	// шаблона в тело HTTP ответа. Последний параметр в Execute() предоставляет
	// возможность отправки динамических данных в шаблон.
	err = ts.Execute(w, nil)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
	}
}

// Обработчик для отображения содержимого заметки.
func showSnippet(w http.ResponseWriter, r *http.Request) {
	// Извлекаем значение параметра id из URL и попытаемся
	// конвертировать строку в integer используя функцию strconv.Atoi(). Если его нельзя
	// конвертировать в integer, или значение меньше 1, возвращаем ответ 404
	/*
		Функция должна получить значение параметра id из URL строки запроса используя метод r.URL.Query().Get().
		Метод будет возвращать значение параметра в виде строки или пустую строку "", если нет совпадающего параметра;

		Поскольку значение из параметра id является ненадежным вводом данных от пользователя,
		значение нужно сперва проверить. Значение из параметра id должно содержать положительное целое число.
		Это можно реализовать если мы попытаемся преобразовать строку из id в целое число
		с помощью функции strconv.Atoi(), а затем проверим если значение больше нуля
	*/
	id, err := strconv.Atoi(r.URL.Query().Get("id"))
	if err != nil || id < 1 {
		http.NotFound(w, r)
		return
	}

	// Используем функцию fmt.Fprintf() для вставки значения из id в строку ответа
	// и записываем его в http.ResponseWriter.
	fmt.Fprintf(w, "Отображение выбранной заметки с ID %d...", id)
	/*
		Если заглянуть в документацию для функции fmt.Fprintf(), вы увидите, что в качестве первого параметра
		принимает интерфейс io.Writer но мы вместо него передали объект http.ResponseWriter — и все сработало хорошо.

		Мы можем это сделать, потому что тип io.Writer является интерфейсом, а объект http.ResponseWriter
		удовлетворяет интерфейсу, потому что у него есть метод w.Write().
	*/
}

// Обработчик для создания новой заметки.
func createSnippet(w http.ResponseWriter, r *http.Request) {
	// Используем r.Method для проверки, использует ли запрос метод POST или нет. Обратите внимание,
	// что http.MethodPost является строкой и содержит текст "POST".
	if r.Method != http.MethodPost {
		// Используем метод Header().Set() для добавления заголовка 'Allow: POST' в
		// карту HTTP-заголовков. Первый параметр - название заголовка, а
		// второй параметр - значение заголовка.
		w.Header().Set("Allow", http.MethodPost)
		/*
			Внимание: Вы должны сперва вызвать метод w.Header().Set()
			и уже потом остальные методы w.WriteHeader() или w.Write()
			иначе ваши изменения не будут учтены.
		*/
		// Если это не так, то вызывается метод w.WriteHeader() для возвращения статус-кода 405
		// и вызывается метод w.Write() для возвращения тела-ответа с текстом "Метод запрещен".
		// Затем мы завершаем работу функции вызовав "return"
		/*
			Вызвать метод w.WriteHeader() в обработчике можно только один раз,
			и после возвращения кода состояния HTTP, изменить его нельзя.
			Если попытаться вызвать w.WriteHeader() во второй раз, Go выдаст сообщение об ошибке

			Если не вызывать метод w.WriteHeader() напрямую, тогда первый вызов w.Write()
			автоматически отправит пользователю код состояния 200 OK. Поэтому, если вы хотите вернуть другой код состояния,
			вызовите один раз метод w.WriteHeader() перед любым вызовом w.Write()
		*/
		//w.WriteHeader(405) // 405 - введённый метод запрещён
		//w.Write([]byte("GET-Метод запрещен!"))
		/*
			Если требуется отправить какой-то код состояния, кроме 200 с текстом ответа, можно использовать http.Error().
			Это вспомогательная функция, которая принимает текст сообщения и код состояния,
			а затем «за кулисами» сама вызывает методы w.WriteHeader() и w.Write().
		*/
		// Используем функцию http.Error() для отправки кода состояния 405 с соответствующим сообщением.
		http.Error(w, "Метод запрещен!", 405)
		return
		/*
			Вызвать метод w.WriteHeader() в обработчике можно только один раз,
			и после возвращения кода состояния HTTP, изменить его нельзя.
			Если попытаться вызвать w.WriteHeader() во второй раз, Go выдаст сообщение об ошибке;

			Если не вызывать метод w.WriteHeader() напрямую, тогда первый вызов w.Write()
			автоматически отправит пользователю код состояния 200 OK.
			Поэтому, если вы хотите вернуть другой код состояния,
			вызовите один раз метод w.WriteHeader() перед любым вызовом w.Write().
		*/
	}

	w.Write([]byte("Создание новой заметки..."))
}

/*
В Go поддерживает два разных типа URL-шаблонов: фиксированные пути и многоуровневые пути.
Фиксированные пути не заканчиваются косой чертой, тогда как многоуровневые пути заканчиваются косой чертой.

Два наших новых шаблона — "/snippet" и "/snippet/create" — являются примерами фиксированных путей.
В servemux такие шаблоны фиксированного пути сопоставляются (и вызывается соответствующий обработчик)
только тогда, когда путь URL-запроса точно совпадает с фиксированным путем.

В то время как, роутинг "/" является примером многоуровневого пути (потому что он заканчивается косой чертой).
Другим примером является что-то вроде "/static/". Шаблоны путей сопоставляются (вызывается соответствующий обработчик)
всякий раз, когда начало пути URL запроса совпадает с путем поддерева.

У многоуровневых путей в конце может быть какой-то вспомогательный символ. К примеру, "/**" или "/static/**".

Теперь понятно, почему шаблон "/" действует по сценарию «catch-all» (ловим все запросы). По сути, данный шаблон
означает совпадение с одним слэшем, за которым следует что-нибудь (или вообще ничего).
*/

/*
УПРАВЛЕНИЕ HTTP ЗАГОЛОВКАМИ В GO

// Устанавливаем новый заголовок управления кешем. Если заголовок "Cache-Control" уже указан
// то он будет переписан.
w.Header().Set("Cache-Control", "public, max-age=31536000")

// Метод Add() добавляет новый заголовок "Cache-Control" и может
// вызываться несколько раз.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")

// Удаляем все значения из заголовка "Cache-Control".
w.Header().Del("Cache-Control")

// Получаем первое значение из заголовка "Cache-Control".
w.Header().Get("Cache-Control")

Название заголовка не чувствительно к регистру. Методы Add(), Get(), Set() и Del() в карте заголовков,
название заголовка всегда будет обработано с помощью функции textproto.CanonicalMIMEHeaderKey().
Эта функция преобразует первую букву и любую букву после дефиса в верхний регистр, а остальные буквы в нижний.

Если требуется избежать такого поведения, можно напрямую отредактировать
базовую карту заголовков (у нее тип map[string][]string)

Метод Del() не удаляет заголовки, сгенерированные системой по умолчанию.
Чтобы подавить их, требуется напрямую получить доступ к базовой карте заголовков и указать значение nil
для нужного вам заголовка. К примеру, если нужно подавить заголовок Date:
w.Header()["Date"] = nil
*/

// Первая версия мэйн
//package main
//
//import (
//	"log"
//	"net/http"
//)
//
//// 1 нам потребуется обработчик(контроллер)
//// Он отвечает за выполнение логики приложения, а также за заголовок и тело HTTP ответа
//
//// 2 - маршрутизатор HTTP запросов (или servemux в Go терминологии).
//// Он хранит связь между URL-шаблонами приложения и соответствующими обработчиками.
//// В приложении один servemux, который содержит все URL маршруты
//
//// Последний - веб-сервер. Одним из преимуществ Go является то, что вы можете использовать встроенный веб-сервер
//// и прослеживать входящие HTTP запросы и все это будет частью самого приложения
////________________________________________________________________________________________________________
//
//// Создается функция-обработчик "home", которая записывает байтовый слайс, содержащий
//// текст "Привет из Snippetbox" как тело ответа.
//func home(w http.ResponseWriter, r *http.Request) {
//	w.Write([]byte("Привет из Snippetbox"))
//}
//
///*
//Функция-обработчик home является обычной функцией с двумя параметрами.
//Параметр http.ResponseWriter предоставляет методы для объединения HTTP ответа и возвращение его пользователю,
//а второй параметр *http.Request является указателем на структуру, которая содержит информацию
//о текущем запросе (вроде HTTP-методов POST, GET, DELETE… и URL текущего запроса)
//*/
//
//func main() {
//	// Используется функция http.NewServeMux() для инициализации нового роутера, затем
//	// функцию "home" регистрируется как обработчик для URL-шаблона "/".
//	mux := http.NewServeMux()
//	mux.HandleFunc("/", home)
//	/*
//		маршрутизатор рассматривает URL-шаблон "/" как «catch-all» — то есть всеобщий захват.
//		Так, что на данный момент все HTTP запросы к веб-серверу будут обрабатываться функцией home,
//		вне зависимости от их URL пути. К примеру, при переходе на другой URL
//		вроде http://localhost:4000/foo будет получен тот же ответ
//	*/
//
//	// Используется функция http.ListenAndServe() для запуска нового веб-сервера.
//	// Мы передаем два параметра: TCP-адрес сети для прослушивания (в данном случае это "localhost:4000")
//	// и созданный роутер. Если вызов http.ListenAndServe() возвращает ошибку
//	// мы используем функцию log.Fatal() для логирования ошибок. Обратите внимание
//	// что любая ошибка, возвращаемая от http.ListenAndServe(), всегда non-nil.
//	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
//	err := http.ListenAndServe(":4000", mux)
//	log.Fatal(err)
//}

// тест методов GET  и POST
//func home(w http.ResponseWriter, r *http.Request) {
//if r.Method == http.MethodGet {
//		w.Write([]byte("Привет из Snippetbox\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//
//	if r.Method == http.MethodPost {
//		w.Write([]byte("Сохраняем в базу данных\n"))
//		w.Write([]byte(r.Method + "\n"))
//		w.Write([]byte(r.RequestURI + "\n"))
//		w.Write([]byte(r.Proto + "\n"))
//		w.Write([]byte("x: " + r.FormValue("x") + "\n"))
//
//		return
//	}
//	w.WriteHeader(http.StatusBadRequest)
//	w.Write([]byte("НЕкорректный метод:" + r.Method + "\n"))
//}
