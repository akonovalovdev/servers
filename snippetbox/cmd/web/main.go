package main

import (
	"database/sql"
	"flag"
	"github.com/akonovalovdev/servers/snippetbox/pkg/models/mysql"
	_ "github.com/go-sql-driver/mysql"
	"log"
	"net/http"
	"os"
)

// Добавляем поле snippets в структуру application. Это позволит
// сделать объект SnippetModel доступным для наших обработчиков.
type application struct {
	errorLog *log.Logger
	infoLog  *log.Logger
	snippets *mysql.SnippetModel
}

type neuteredFileSystem struct {
	fs http.FileSystem
}

/*
ОБЯЗАННОСТИ ФУНКЦИИ МЭЙН НА ДАННЫЙ МОМЕНТ
- Парсинг настроек конфигурации среды выполнения для приложения;
- Установление зависимостей для обработчиков;
- Запуск HTTP-сервера.
*/
func main() {
	addr := flag.String("addr", ":4000", "Сетевой адрес веб-сервера")
	// Определение нового флага из командной строки для настройки MySQL подключения.
	dsn := flag.String("dsn", "web:password13@/snippetbox?parseTime=true", "Название MySQL источника данных")
	flag.Parse()

	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
	errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)

	// Чтобы функция main() была более компактной, мы поместили код для создания
	// пула соединений в отдельную функцию openDB(). Мы передаем в нее полученный
	// источник данных (DSN) из флага командной строки.
	db, err := openDB(*dsn)
	if err != nil {
		errorLog.Fatal(err)
	}

	// Мы также откладываем вызов db.Close(), чтобы пул соединений был закрыт
	// до выхода из функции main().
	// Подробнее про defer: https://golangs.org/errors#defer
	defer db.Close()

	// Инициализируем экземпляр mysql.SnippetModel и добавляем его в зависимостях.
	app := &application{
		errorLog: errorLog,
		infoLog:  infoLog,
		snippets: &mysql.SnippetModel{DB: db},
	}

	srv := &http.Server{
		Addr:     *addr,
		ErrorLog: errorLog,
		Handler:  app.routes(), // Вызов нового метода app.routes()
	}

	infoLog.Printf("Запуск сервера на %s", *addr)
	// Поскольку переменная `err` уже объявлена в приведенном выше коде, нужно
	// использовать оператор присваивания =
	// вместо оператора := (объявить и присвоить)
	err = srv.ListenAndServe()
	errorLog.Fatal(err)
}

// Функция openDB() обертывает sql.Open() и возвращает пул соединений sql.DB
// для заданной строки подключения (DSN).
func openDB(dsn string) (*sql.DB, error) {
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, err
	}
	if err = db.Ping(); err != nil {
		return nil, err
	}
	return db, nil
}

// Второй MAIN (до переноса маршрутов)
///*
//	Усовершенствуем наше приложение, добавив возможность многоуровнего логирования,
//	чтобы информационные сообщения и сообщения об ошибках обрабатывались по-разному. А именно:
//
//	Информационным сообщениям добавим префикс "INFO". Такое сообщение будет
//	выводиться в стандартный поток вывода (stdout);
//
//	Сообщениям об ошибках добавим префикс "ERROR". Такие сообщения будут выводиться в стандартный
//	поток ошибок (stderr) вместе с соответствующим названием файла и номером строки,
//	которая вызвала логгер для записи (это поможет в отладке на будущее).
//
//	Самый простой и понятный подход заключается в использовании функции log.New()
//	для создания двух новых настраиваемых логгеров
//
//	Перенаправление в файлы:
//	go run ./cmd/web >>/tmp/info.log 2>>/tmp/error.log
//*/
//
//// Создаем структуру `application` для хранения зависимостей всего веб-приложения.
//// Пока, что мы добавим поля только для двух логгеров, но
//// мы будем расширять данную структуру по мере усложнения приложения.
///* <ПАТТЕРН Dependency Injection (ВНЕДРЕНИЕ ЗАВИСИМОСТЕЙ)> */
//type application struct {
//	errorLog *log.Logger
//	infoLog  *log.Logger
//}
//
//func main() {
//	addr := flag.String("addr", ":4000", "Сетевой адрес веб-сервера")
//	flag.Parse()
//
//	// Используйте log.New() для создания логгера для записи информационных сообщений. Для этого нужно
//	// три параметра: место назначения для записи логов (os.Stdout), строка
//	// с префиксом сообщения (INFO или ERROR) и флаги, указывающие, какая
//	// дополнительная информация будет добавлена. Обратите внимание, что флаги
//	// соединяются с помощью оператора OR |.
//	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
//
//	// Создаем логгер для записи сообщений об ошибках таким же образом, но используем stderr как
//	// место для записи и используем флаг log.Lshortfile для включения в лог
//	// названия файла и номера строки где обнаружилась ошибка.
//	errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
//	/*
//		На заметку: Если вы хотите включить весь путь файла в лог  вместо просто названия файла,
//		при создании логгера можно использовать флаг log.Llongfile вместо log.Lshortfile.
//		Вы также можете заставить свой логгер  использовать UTC дату (вместо локальной), добавив флаг log.LUTC.
//
//		Новые логгеры, созданные с помощью log.New(), конкурентно-безопасны.
//		Вы можете делиться одним логгером и использовать его в нескольких горутинах,
//		не беспокоясь об возможных конфликтах между ними из за записи сообщений в одном и том же логгере.
//
//		Если у вас есть несколько логгеров, использующих для записи одно и то же место назначения,
//		вам требуется убедиться, что базовый метод  Write() также безопасен для конкурентного использования.
//	*/
//	// Инициализируем новую структуру с зависимостями приложения.
//	app := &application{
//		errorLog: errorLog,
//		infoLog:  infoLog,
//	}
//
//	// Используем методы из структуры в качестве обработчиков маршрутов.
//	mux := http.NewServeMux()
//	mux.HandleFunc("/", app.home)
//	mux.HandleFunc("/snippet", app.showSnippet)
//	mux.HandleFunc("/snippet/create", app.createSnippet)
//
//	fileServer := http.FileServer(neuteredFileSystem{http.Dir("./snippetbox/ui/static/")})
//	mux.Handle("/static", http.NotFoundHandler())
//	mux.Handle("/static/", http.StripPrefix("/static", fileServer))
//
//	// По умолчанию, если HTTP-сервер обнаруживает ошибку,
//	// он логирует её с помощью стандартного логгера. Но, лучше использовать наш новый логгер errorLog.
//	/*
//		Нам требуется инициализировать новую структуру http.Server,
//		содержащую параметры конфигурации для сервера, вместо использования http.ListenAndServe().
//	*/
//
//	// Инициализируем новую структуру http.Server. Мы устанавливаем поля Addr и Handler, так
//	// что сервер использует тот же сетевой адрес и маршруты, что и раньше, и назначаем
//	// поле ErrorLog, чтобы сервер использовал наш логгер
//	// при возникновении проблем.
//	srv := &http.Server{
//		Addr:     *addr,
//		ErrorLog: errorLog,
//		Handler:  mux,
//	}
//	// Применяем созданные логгеры к нашему приложению.
//	infoLog.Printf("Запуск сервера на %s", *addr)
//	// Вызываем метод ListenAndServe() от нашей новой структуры http.Server
//	err := srv.ListenAndServe()
//	// Как правило, лучше избегать использования методов Panic() и Fatal() за пределами функции main().
//	// Вместо этого рекомендуется возвращать возникшие ошибки,
//	// а паниковать или принудительно завершать приложение непосредственно из самого main().
//	errorLog.Fatal(err)
//	/*
//		Обратите внимание, что у этих двух сообщений разные префиксы —
//		чтобы их можно было легко различить в терминале — и наше сообщение об ошибке также включает в себя
//		название файла и номер строки (main.go:37), которая вызывает логгер для записи возникнувшей ошибки.
//	*/
//}
//
///*
//	Большое преимущество логирования сообщений в стандартных потоках (stdout и stderr),
//	как у нас, заключается в том, что само приложение и логирование не связаны.
//	Само приложение не занимается маршрутизацией или хранением логов,
//	и это может упростить управление логами, которое будет различаться в зависимости от среды.
//
//	Стандартные потоки отображаются в терминале,
//	поэтому вывод логов можно легко посмотреть после запуска приложения из терминала.
//
//	Если приложение запущено в рабочем режиме и обслуживает реальных пользователей,
//	то наши логи должны записываться в специальном месте.
//	Таким местом могут быть файлы на диске или различные сервисы мониторинга работы приложения
//	_____________________________________________________________________________________________________________
//	Логирование сообщений в файл
//	Как было сказано выше, лучше записывать вывод в стандартные потоки
//	и перенаправлять вывод в файл при запуске приложения из командной строки. Но, если вы не хотите этого делать,
//	всегда можно открыть файл в Go и использовать его в качестве места назначения лога.
//	Например:
//		f, err := os.OpenFile("info.log", os.O_RDWR|os.O_CREATE, 0666)
//		if err != nil {
//		    log.Fatal(err)
//		}
//		defer f.Close()
//
//		infoLog := log.New(f, "INFO\t", log.Ldate|log.Ltime)
//*/
//
//func (nfs neuteredFileSystem) Open(path string) (http.File, error) {
//	f, err := nfs.fs.Open(path)
//	if err != nil {
//		return nil, err
//	}
//
//	s, err := f.Stat()
//	if s.IsDir() {
//		index := filepath.Join(path, "index.html")
//		if _, err := nfs.fs.Open(index); err != nil {
//			closeErr := f.Close()
//			if closeErr != nil {
//				return nil, closeErr
//			}
//
//			return nil, err
//		}
//	}
//	return f, nil
//}

// Первый MAIN
//
//// Тип для настраиваемой файловой системы, который включает в себя http.FileSystem
//type neuteredFileSystem struct {
//	fs http.FileSystem
//}
//
//func main() {
//	// Регистрируем обработчики и соответствующие URL-шаблоны в маршрутизаторе servemux
//	mux := http.NewServeMux()
//	// Превращаем функции home, showSnippet, createSnippet в обработчики используя адаптер http.HandlerFunc()
//	// mux := http.NewServeMux()
//	// mux.Handle("/", http.HandlerFunc(home))
//
//	/*
//		Адаптер http.HandlerFunc() работает путем автоматического добавления метода ServeHTTP()
//		для функции home(). При выполнении, метод ServeHTTP() просто вызывает контент из оригинальной функции home().
//		Это обходной, но удобный способ заставить обычную функцию соответствовать требованиям интерфейса http.Handler
//	*/
//
//	// Ниже для регистрации функций в качестве обработчиков с помощью servemux, мы использовали метод HandleFunc().
//	// Это СИНТАКСИЧЕСКИЙ САХАР, который сразу превращает функцию в обработчик
//	// и регистрирует её, вместо того, чтобы это делать нам вручную.
//	//
//	// Такой формат более компактный и выполняет ту же задачу как и код выше:
//	mux.HandleFunc("/", home)
//	mux.HandleFunc("/snippet", showSnippet)
//	mux.HandleFunc("/snippet/create", createSnippet)
//
//	/*
//			Ограничение просмотра файлов из директории
//		1-способ
//		Добавьте пустой файл index.html в ту директорию, где требуется отключить
//		вывод списка файлов. Веб-сервер всегда ищет файл index.html,
//		и пользователь увидит пустую страницу с кодом состояния 200 OK.
//		2-способ
//		Настраиваемая имплементация файловой системы http.FileSystem,
//		с помощью которой будет возвращаться ошибка os.ErrNotExist
//		для любого HTTP запроса напрямую к папке
//	*/
//	// Инициализируем FileServer, он будет обрабатывать
//	// HTTP-запросы к статическим файлам из папки "./ui/static".
//	// Использование настраиваемой файловой системы, добавив новую структуру neuteredFileSystem и метод Open для неё
//	fileServer := http.FileServer(neuteredFileSystem{http.Dir("./snippetbox/ui/static/")})
//	/*
//		Иногда может потребоваться обслужить только один статический файл. Для этой задачи,
//		функция http.ServeFile() используется следующим образом:
//
//		func downloadHandler(w http.ResponseWriter, r *http.Request) {
//		    http.ServeFile(w, r, "./ui/static/file.zip")
//		}
//
//		Внимание: Обработчик http.ServeFile() автоматически не очищает путь файла. Если вы указываете
//		в данную функцию путь к файлу полученный от пользователя напрямую, во избежание атак обхода директории,
//		перед использование этих данных, обязательно очистите их с помощью функции filepath.Clean().
//		Иначе, пользователь сможет скачать различные файлы с сервера включая файл с настройками к базе данных.
//	*/
//
//	// Используем функцию mux.Handle() для регистрации обработчика для
//	// всех запросов, которые начинаются с "/static/". Мы убираем
//	// префикс "/static" перед тем как запрос достигнет http.FileServer
//	mux.Handle("/static", http.NotFoundHandler())
//	mux.Handle("/static/", http.StripPrefix("/static", fileServer))
//
//	log.Println("Запуск веб-сервера на http://127.0.0.1:4000")
//	err := http.ListenAndServe(":4000", mux) // Информационное сообщение
//	/*
//		Функция http.ListenAndServe() принимает объект http.Handler в качестве второго параметра…
//			func ListenAndServe(addr string, handler Handler) error
//		… но мы передали servemux вместо http.Handler.
//
//		Мы смогли это сделать, потому что у servemux также есть метод ServeHTTP().
//		Это значит, что он также соответствует требованиям интерфейса http.Handler
//
//		Проще думать о servemux как об особом обработчике, который вместо предоставления ответа передает
//		запрос второму обработчику. Это не такой уж большой скачок, как может показаться на первый взгляд.
//		Объединение обработчиков в цепочку — очень распространенная идиома в Go,
//		которую мы часто будем использовать в будущем при работе с нашим веб-проектом.
//
//		происходит следующее:
//		1. Когда сервер получает новый HTTP-запрос, он вызывает метод ServeHTTP() от servemux;
//		2. Он ищет соответствующий обработчик на основе URL запроса и, в свою очередь,
//			вызывает метод ServeHTTP() данного обработчика.
//
//		Можно рассматривать веб-приложение как цепочку из ServeHTTP() методов, вызываемых один за другим
//	*/
//	log.Fatal(err) // Сообщение об фатальной ошибке в работе программы
//	/*
//		Функции log.Printf() и log.Fatal(). выводят сообщения через стандартный логгер,
//		который по умолчанию добавляет к сообщениям префиксы с локальной датой и временем и записывает
//		их в стандартный поток ошибок (который должен отображаться в окне терминала).
//		Функция log.Fatal() также вызовет os.Exit(1) после того как выведет
//		в терминал сообщение об ошибке, это приведет к мгновенному завершению работы приложения.
//
//		Логгирование можно поделить на два различных типа, или уровня. К первому типу относятся
//		информационные сообщения (вроде «Запуск сервера на :4000«), а ко второму типу относятся сообщения об ошибках.
//	*/
//}
//
//// Создаем метод Open(), который вызывается каждый раз, когда http.FileServer получает запрос
//func (nfs neuteredFileSystem) Open(path string) (http.File, error) {
//	// Открываем вызываемый путь
//	f, err := nfs.fs.Open(path)
//	if err != nil {
//		return nil, err
//	}
//
//	s, err := f.Stat()
//	// Используя метод IsDir() мы проверим если вызываемый путь является папкой или нет
//	if s.IsDir() {
//		// Если это папка, то с помощью метода Stat("index.html") мы проверим если файл index.html существует внутри данной папки
//		index := filepath.Join(path, "index.html")
//		// Если файл index.html не существует, то метод вернет ошибку os.ErrNotExist
//		// которая, в свою очередь, будет преобразована через http.FileServer в ответ 404 страница не найдена
//		if _, err := nfs.fs.Open(index); err != nil {
//			// Мы также вызываем метод Close() для закрытия только, что открытого index.html файла,
//			// чтобы избежать утечки файлового дескриптора
//			closeErr := f.Close()
//			if closeErr != nil {
//				return nil, closeErr
//			}
//
//			return nil, err
//		}
//	}
//	// Во всех остальных случаях мы просто возвращаем файл и даем http.FileServer сделать то, что он должен.
//	return f, nil
//}
