Причиной появления Swagger было стремление к созданию системы автоматического генерирования
документации для REST API, а так же — желание автоматизации испытаний API. Вспомните скрипт
manual.sh из репозитория к первому материалу этой серии. Этот скрипт содержит набор команд curl,
предназначенных для взаимодействия с сервером. Ясно, что подобные команды могут быть сгенерированы
автоматически на основе стандартизированного описания REST API. Это способно сэкономить много времени.

OpenAPI — это современное название спецификации, а словом «Swagger» обычно называют инструменты,
построенные на основе этой спецификации правда, можно ещё столкнуться и с таким понятием, как «спецификация Swagger»

В спецификации OpenAPI можно описать произвольное количество путей, с каждым из которых сопоставлены различные методы
(GET, POST и так далее). В описаниях путей имеются сведения об их параметрах и об ответах, а так же о JSON-схемах.
______________________________________________________________________________________________________________________
Возможности, которые обещают нам OpenAPI/Swagger, выходят далеко за пределы автоматического создания документации.
На основе соответствующих спецификаций можно автоматически генерировать код клиентов и серверов.

Инструмент swagger-codegen умеет ещё и создавать код клиентов, в том числе и на Go.
Иногда это может оказаться очень кстати, но с моей точки зрения подобный
код выглядит несколько запутанным. Он, как и в случае с серверным кодом,
возможно, может сыграть роль хорошей отправной точки в деле написания собственного клиента,
но механизм его автоматического создания вряд ли может стать частью некоего CI/CD-процесса.
______________________________________________________________________________________________________________________
В документации можно щёлкать по её элементам, их можно раскрывать,
можно видеть чёткие описания параметров запросов, ответов, JSON-схем и прочего подобного.
______________________________________________________________________________________________________________________
инструмент для генерирования кода — oapi-codegen. https://github.com/deepmap/oapi-codegen
код написанный на это инструменте: https://github.com/eliben/code-for-blog/tree/master/2021/go-rest-servers/swagger/oapi-server

Я должен признать, что результаты работы oapi-codegen понравились мне гораздо больше, чем код,
созданный другими опробованными мной инструментами.
Это — простой и чистый код, при работе с которым легко отделить то, что сгенерировано автоматически, от того,
что написано самостоятельно. Средство oapi-codegen даже понимает спецификации OpenAPI 3!
______________________________________________________________________________________________________________________
В первую очередь отмечу, что go-swagger поддерживает лишь спецификацию Swagger 2.0,
а не более новую версию OpenAPI 3.0. Это довольно-таки печально,
но я нашёл один онлайновый инструмент https://lucybot-inc.github.io/api-spec-converter/ , который умеет конвертировать описания API,
выполненные с использованием спецификации OpenAPI 3.0 в описания формата OpenAPI 2.0 (Swagger).

В серверном коде, сгенерированном go-swagger, определённо, реализовано больше возможностей,
чем в коде, сгенерированном swagger-codegen. Но за всё надо платить.
Дополнительные возможности означают привязку к особому фреймворку, разработанному создателями go-swagger.
Сгенерированный код имеет множество зависимостей от пакетов из репозиториев go-openapi,
в нём код из этих пакетов широко используется для обеспечения работы сервера.
Там есть даже код для разбора флагов. Собственно, почему бы ему там не быть?

Если вам нравится фреймворк, используемый в коде, генерируемом go-swagger, то вам вполне может подойти этот код.
Но если у вас на этот счёт есть свои идеи — вроде использования Gin или собственного маршрутизатора,
то решения разработчиков go-swagger, отразившиеся на готовом коде, могут вас не устроить.